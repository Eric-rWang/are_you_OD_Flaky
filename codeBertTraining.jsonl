{"code": "def test_jwt_route(self, jwt_router_client, entity_model, expected):\n        rv = jwt_router_client.get(\"/test\")\n        assert expected in str(rv.status)", "label": "victim", "fix": "87a88\n >  rv = jwt_router_client.get('/test')"}
{"code": "def test_loading_failure():\n    test_clear()\n    with open(file_path, \"w\") as f:\n        f.write(\"\"\"\nfrom breathe import Breathe\nfrom ..testutils import DoNothing\n\nBreathe.add_commands(,,,\n    None,\n    {\n        \"apple\": DoNothing(),\n    }\n)\n\"\"\"\n        )\n    modules = {\n        \"tests\": {\n            \"my_grammar\": [\"fruit\"],\n        }\n    }\n    Breathe.load_modules(modules)\n    assert len(Breathe.modules) == 1\n    assert len(Breathe.core_commands) == 0", "label": "victim", "fix": "11a12\n >  Breathe.clear()"}
{"code": "def test_loading():\n    with open(file_path, \"w\") as f:\n        f.write(\"\"\"\nfrom breathe import Breathe\nfrom ..testutils import DoNothing\n\nBreathe.add_commands(\n    None,\n    {\n        \"apple\": DoNothing(),\n    }\n)\n\"\"\"\n        )\n    engine.mimic(\"rebuild everything test\")\n    engine.mimic(\"apple\")", "label": "brittle", "fix": "34a35,39\n >  with open(file_path, 'w') as f:\n >  f.write('\\nfrom breathe import Breathe\\nfrom ..testutils import DoNothing\\n\\nBreathe.add_commands(,,,\\n None,\\n {\\n \"apple\": DoNothing(),\\n }\\n)\\n')\n >  modules = {'tests': {'my_grammar': ['fruit']}}\n >  Breathe.load_modules(modules)\n >  assert (len(Breathe.modules) == 1)"}
{"code": "def test_reloading():\n    with open(file_path, \"w\") as f:\n        f.write(\"\"\"\nfrom breathe import Breathe\nfrom ..testutils import DoNothing\n\nBreathe.add_commands(\n    None,\n    {\n        \"parsnip\": DoNothing(),\n    }\n)\n\"\"\"\n        )\n    # I have no idea why this is necessary, it's a total hack\n    if PY2:\n        os.remove(file_path + \"c\")\n    engine.mimic(\"rebuild everything test\")\n    with pytest.raises(MimicFailure):\n        engine.mimic(\"apple\")\n    engine.mimic(\"parsnip\")\n    assert len(Breathe.modules) == 1", "label": "brittle", "fix": "51a52,56\n >  with open(file_path, 'w') as f:\n >  f.write('\\nfrom breathe import Breathe\\nfrom ..testutils import DoNothing\\n\\nBreathe.add_commands(,,,\\n None,\\n {\\n \"apple\": DoNothing(),\\n }\\n)\\n')\n >  modules = {'tests': {'my_grammar': ['fruit']}}\n >  Breathe.load_modules(modules)\n >  assert (len(Breathe.modules) == 1)"}
{"code": "def test_core_commands():\n    Breathe.add_commands(\n        None,\n        {\n            \"test one\": DoNothing(),\n            \"test two\": DoNothing(),\n            \"test three\": DoNothing(),\n            \"banana [<n>]\": DoNothing() * Repeat(\"n\"),\n        },\n        [IntegerRef(\"n\", 1, 10, 1)],\n    )\n    engine.mimic([\"test\", \"three\", \"test\", \"two\", \"banana\", \"five\"])", "label": "victim", "fix": "27a28\n >  engine.mimic(['disable', 'test'])"}
{"code": "def test_context_commands():\n    Breathe.add_commands(\n        AppContext(\"notepad\"),\n        {\"test [<num>]\": lambda num: DoNothing().execute()},\n        [Choice(\"num\", {\"four\": \"4\", \"five\": \"5\", \"six\": \"6\"})],\n        {\"num\": \"\"},\n    )\n    with pytest.raises(MimicFailure):\n        engine.mimic([\"test\", \"three\", \"test\", \"four\"])\n    engine.mimic([\"test\", \"three\", \"test\", \"four\"], executable=\"notepad\")", "label": "brittle", "fix": "41a42\n >  Breathe.add_commands(None, {'test one': DoNothing(), 'test two': DoNothing(), 'test three': DoNothing(), 'banana [<n>]': (DoNothing() * Repeat('n'))}, [IntegerRef('n', 1, 10, 1)])"}
{"code": "def test_noccr_commands():\n    Breathe.add_commands(\n        AppContext(\"firefox\"),\n        {\"dictation <text>\": DoNothing(), \"testing static\": DoNothing()},\n        ccr=False,\n    )\n    engine.mimic([\"testing\", \"static\"], executable=\"firefox\")\n    with pytest.raises(MimicFailure):\n        engine.mimic([\"dictation\", \"TESTING\"])\n        engine.mimic([\"testing\", \"static\", \"testing\", \"static\"], executable=\"firefox\")\n    engine.mimic([\"dictation\", \"TESTING\"], executable=\"firefox\")", "label": "brittle", "fix": "53a54\n >  Breathe.add_global_extras(Dictation('text'))"}
{"code": "def test_invalid():\n    Breathe.add_commands(\n        AppContext(\"code.exe\"),\n        {\n            \"test that <nonexistent_extra>\": DoNothing(),\n            1: DoNothing(),\n        },\n    )\n    assert len(Breathe.contexts) == 1\n    assert len(Breathe.context_commands) == 1", "label": "brittle", "fix": "76a77\n >  Breathe.add_commands(CommandContext('test'), {'pizza': DoNothing(), 'curry': DoNothing()})"}
{"code": "def test_create_user():\n    \"\"\"\n    This runs through various iterations of creating a user.\n\n    \"\"\"\n    try:\n        os.remove(\"test-creation.authdb.sqlite\")\n    except Exception:\n        pass\n    try:\n        os.remove(\"test-creation.authdb.sqlite-shm\")\n    except Exception:\n        pass\n    try:\n        os.remove(\"test-creation.authdb.sqlite-wal\")\n    except Exception:\n        pass\n\n    get_test_authdb()\n    suff_list = get_public_suffix_list()\n\n    # 0a. full name spam with no http://\n    payload = {\n        \"full_name\": \"Test User bIt.Ly/hahaspam\",\n        \"email\": \"testuser@test.org\",\n        \"password\": \"password\",\n        \"reqid\": 1,\n        \"pii_salt\": \"super-random-salt\",\n        \"public_suffix_list\": suff_list,\n    }\n    user_created = actions.create_new_user(\n        payload, override_authdb_path=\"sqlite:///test-creation.authdb.sqlite\"\n    )\n    assert user_created[\"success\"] is False\n    assert user_created[\"user_email\"] is None\n    assert user_created[\"user_id\"] is None\n    assert user_created[\"send_verification\"] is False\n    assert user_created[\"failure_reason\"] == \"invalid full name\"\n\n    # 0b. full name spam with http://\n    payload = {\n        \"full_name\": \"Test User HttPs://BIT.lY/hahaspam\",\n        \"email\": \"testuser@test.org\",\n        \"password\": \"password\",\n        \"reqid\": 1,\n        \"pii_salt\": \"super-random-salt\",\n        \"public_suffix_list\": suff_list,\n    }\n    user_created = actions.create_new_user(\n        payload, override_authdb_path=\"sqlite:///test-creation.authdb.sqlite\"\n    )\n    assert user_created[\"success\"] is False\n    assert user_created[\"user_email\"] is None\n    assert user_created[\"user_id\"] is None\n    assert user_created[\"send_verification\"] is False\n    assert user_created[\"failure_reason\"] == \"invalid full name\"\n\n    # 0c. full name spam with http:// and checking if currproc works OK\n    payload = {\n        \"full_name\": \"Test User HttPs://BIT.lY/hahaspam\",\n        \"email\": \"testuser@test.org\",\n        \"password\": \"password\",\n        \"reqid\": 1,\n        \"pii_salt\": \"super-random-salt\",\n    }\n    user_created = actions.create_new_user(\n        payload, override_authdb_path=\"sqlite:///test-creation.authdb.sqlite\"\n    )\n    assert user_created[\"success\"] is False\n    assert user_created[\"user_email\"] is None\n    assert user_created[\"user_id\"] is None\n    assert user_created[\"send_verification\"] is False\n    assert user_created[\"failure_reason\"] == \"invalid full name\"\n\n    # 1. dumb password\n    payload = {\n        \"full_name\": \"Test User\",\n        \"email\": \"testuser@test.org\",\n        \"password\": \"password\",\n        \"reqid\": 1,\n        \"pii_salt\": \"super-random-salt\",\n        \"public_suffix_list\": suff_list,\n    }\n    user_created = actions.create_new_user(\n        payload, override_authdb_path=\"sqlite:///test-creation.authdb.sqlite\"\n    )\n    assert user_created[\"success\"] is False\n    assert user_created[\"user_email\"] == \"testuser@test.org\"\n    assert user_created[\"user_id\"] is None\n    assert user_created[\"send_verification\"] is False\n    assert (\n        \"Your password is too short. It must have at least 12 characters.\"\n        in user_created[\"messages\"]\n    )\n    assert (\n        \"Your password is too similar to either \"\n        \"the domain name of this server or your \"\n        \"own name or email address.\" in user_created[\"messages\"]\n    )\n    assert (\n        \"Your password is on the list of the most common \"\n        \"passwords and is vulnerable to guessing.\" in user_created[\"messages\"]\n    )\n\n    # 1a. 'clever'-dumb password\n    payload = {\n        \"full_name\": \"Test User\",\n        \"email\": \"testuser@test.org\",\n        \"password\": \"passwordpassword123\",\n        \"reqid\": 1,\n        \"pii_salt\": \"super-random-salt\",\n    }\n    user_created = actions.create_new_user(\n        payload, override_authdb_path=\"sqlite:///test-creation.authdb.sqlite\"\n    )\n    assert user_created[\"success\"] is False\n    assert user_created[\"user_email\"] == \"testuser@test.org\"\n    assert user_created[\"user_id\"] is None\n    assert user_created[\"send_verification\"] is False\n    msg_found = False\n    for msg in user_created[\"messages\"]:\n        if \"recently compromised Web account passwords from\" in msg:\n            msg_found = True\n            break\n    assert msg_found, f\"Pwned message not in {user_created['messages']}\"\n\n    # 2. all numeric password\n    payload = {\n        \"full_name\": \"Test User\",\n        \"email\": \"testuser@test.org\",\n        \"password\": \"239420349823904802398402375025\",\n        \"reqid\": 1,\n        \"pii_salt\": \"super-random-salt\",\n        \"public_suffix_list\": suff_list,\n    }\n    user_created = actions.create_new_user(\n        payload, override_authdb_path=\"sqlite:///test-creation.authdb.sqlite\"\n    )\n    assert user_created[\"success\"] is False\n    assert user_created[\"user_email\"] == \"testuser@test.org\"\n    assert user_created[\"user_id\"] is None\n    assert user_created[\"send_verification\"] is False\n    assert \"Your password cannot be all numbers.\" in user_created[\"messages\"]\n\n    # 3a. password ~= email address\n    payload = {\n        \"full_name\": \"Test User\",\n        \"email\": \"testuser@test.org\",\n        \"password\": \"testuser\",\n        \"reqid\": 1,\n        \"pii_salt\": \"super-random-salt\",\n    }\n    user_created = actions.create_new_user(\n        payload, override_authdb_path=\"sqlite:///test-creation.authdb.sqlite\"\n    )\n    assert user_created[\"success\"] is False\n    assert user_created[\"user_email\"] == \"testuser@test.org\"\n    assert user_created[\"user_id\"] is None\n    assert user_created[\"send_verification\"] is False\n    assert (\n        \"Your password is too similar to either \"\n        \"the domain name of this server or your \"\n        \"own name or email address.\" in user_created[\"messages\"]\n    )\n\n    # 3b. password ~= full name\n    payload = {\n        \"full_name\": \"Test User\",\n        \"email\": \"testuser@test.org\",\n        \"password\": \"TestUser123\",\n        \"reqid\": 1,\n        \"pii_salt\": \"super-random-salt\",\n        \"public_suffix_list\": suff_list,\n    }\n    user_created = actions.create_new_user(\n        payload, override_authdb_path=\"sqlite:///test-creation.authdb.sqlite\"\n    )\n    assert user_created[\"success\"] is False\n    assert user_created[\"user_email\"] == \"testuser@test.org\"\n    assert user_created[\"user_id\"] is None\n    assert user_created[\"send_verification\"] is False\n    assert (\n        \"Your password is too similar to either \"\n        \"the domain name of this server or your \"\n        \"own name or email address.\" in user_created[\"messages\"]\n    )\n\n    # 4. password is OK\n    payload = {\n        \"full_name\": \"Test User\",\n        \"email\": \"testuser@test.org\",\n        \"password\": \"aROwQin9L8nNtPTEMLXd\",\n        \"system_id\": \"totally-random-systemid-1234\",\n        \"reqid\": 1,\n        \"pii_salt\": \"super-random-salt\",\n    }\n    user_created = actions.create_new_user(\n        payload, override_authdb_path=\"sqlite:///test-creation.authdb.sqlite\"\n    )\n    assert user_created[\"success\"] is True\n    assert user_created[\"user_email\"] == \"testuser@test.org\"\n    assert user_created[\"user_id\"] == 4\n    assert user_created[\"system_id\"] == \"totally-random-systemid-1234\"\n    assert user_created[\"send_verification\"] is True\n    assert (\n        \"User account created. Please verify your email address to log in.\"\n        in user_created[\"messages\"]\n    )\n\n    # 5. try to create a new user with an existing email address\n    payload = {\n        \"full_name\": \"Test User\",\n        \"email\": \"testuser@test.org\",\n        \"password\": \"aROwQin9L8nNtPTEMLXd\",\n        \"reqid\": 1,\n        \"pii_salt\": \"super-random-salt\",\n        \"public_suffix_list\": suff_list,\n    }\n    user_created = actions.create_new_user(\n        payload, override_authdb_path=\"sqlite:///test-creation.authdb.sqlite\"\n    )\n    assert user_created[\"success\"] is False\n    assert user_created[\"user_email\"] == \"testuser@test.org\"\n    assert user_created[\"user_id\"] == 4\n\n    # we should not send a verification email because the user already has an\n    # account or if the account is not active yet, the last verification email\n    # was sent less than 24 hours ago\n    assert user_created[\"send_verification\"] is False\n    assert (\n        \"User account created. Please verify your email address to log in.\"\n        in user_created[\"messages\"]\n    )\n\n    try:\n        os.remove(\"test-creation.authdb.sqlite\")\n    except Exception:\n        pass\n    try:\n        os.remove(\"test-creation.authdb.sqlite-shm\")\n    except Exception:\n        pass\n    try:\n        os.remove(\"test-creation.authdb.sqlite-wal\")\n    except Exception:\n        pass", "label": "victim", "fix": "24a25,51\n >  user_payload = {'full_name': 'Test User', 'email': 'testuser-sessiondelete@test.org', 'password': 'aROwQin9L8nNtPTEMLXd', 'pii_salt': 'super-secret-salt', 'reqid': 1}\n >  user_created = actions.create_new_user(user_payload, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  emailverify = actions.set_user_emailaddr_verified({'email': user_payload['email'], 'user_id': user_created['user_id'], 'pii_salt': 'super-secret-salt', 'reqid': 1}, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  assert (emailverify['success'] is True)\n >  assert (emailverify['user_role'] == 'authenticated')\n >  session_payload = {'user_id': emailverify['user_id'], 'user_agent': 'Mozzarella Killerwhale', 'expires': (datetime.utcnow() + timedelta(hours=1)), 'ip_address': '1.1.1.1', 'extra_info_json': {'pref_datasets_always_private': True}, 'pii_salt': 'super-secret-salt', 'reqid': 1}\n >  session_token1 = actions.auth_session_new(session_payload, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  session_payload = {'user_id': emailverify['user_id'], 'user_agent': 'Searchzilla Oxide', 'expires': (datetime.utcnow() + timedelta(hours=1)), 'ip_address': '1.1.1.2', 'extra_info_json': {'pref_datasets_always_private': True}, 'pii_salt': 'super-secret-salt', 'reqid': 1}\n >  session_token2 = actions.auth_session_new(session_payload, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  session_payload = {'user_id': emailverify['user_id'], 'user_agent': 'Pear Adventure', 'expires': (datetime.utcnow() + timedelta(hours=1)), 'ip_address': '1.1.1.3', 'extra_info_json': {'pref_datasets_always_private': True}, 'pii_salt': 'super-secret-salt', 'reqid': 1}\n >  session_token3 = actions.auth_session_new(session_payload, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  sessions_killed = actions.auth_delete_sessions_userid({'user_id': emailverify['user_id'], 'session_token': session_token3['session_token'], 'keep_current_session': True, 'pii_salt': 'super-secret-salt', 'reqid': 1}, raiseonfail=True, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  assert (sessions_killed['success'] is True)\n >  session_check_1 = actions.auth_session_exists({'session_token': session_token1['session_token'], 'pii_salt': 'super-secret-salt', 'reqid': 1}, raiseonfail=True, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  assert (session_check_1['success'] is False)\n >  session_check_2 = actions.auth_session_exists({'session_token': session_token2['session_token'], 'pii_salt': 'super-secret-salt', 'reqid': 1}, raiseonfail=True, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  assert (session_check_2['success'] is False)\n >  session_check_3 = actions.auth_session_exists({'session_token': session_token3['session_token'], 'pii_salt': 'super-secret-salt', 'reqid': 1}, raiseonfail=True, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  assert (session_check_3['success'] is True)\n >  currproc = mp.current_process()\n >  if getattr(currproc, 'authdb_engine', None):\n >  currproc.authdb_engine.dispose()\n >  del currproc.authdb_engine\n >  try:\n >  os.remove('test-sessiondelete.authdb.sqlite')\n >  except Exception:\n >  pass"}
{"code": "def test_role_permissions():\n    \"\"\"\n    This tests if we can check the permissions for a logged-in user.\n\n    \"\"\"\n\n    try:\n        os.remove(\"test-permcheck.authdb.sqlite\")\n    except Exception:\n        pass\n    try:\n        os.remove(\"test-permcheck.authdb.sqlite-shm\")\n    except Exception:\n        pass\n    try:\n        os.remove(\"test-permcheck.authdb.sqlite-wal\")\n    except Exception:\n        pass\n\n    get_test_authdb()\n    get_public_suffix_list()\n\n    # create the user\n    user_payload = {\n        \"full_name\": \"Test User\",\n        \"email\": \"testuser-permcheck@test.org\",\n        \"password\": \"aROwQin9L8nNtPTEMLXd\",\n        \"pii_salt\": \"super-secret-salt\",\n        \"reqid\": 1,\n    }\n    user_created = actions.create_new_user(\n        user_payload,\n        override_authdb_path=\"sqlite:///test-permcheck.authdb.sqlite\",\n    )\n    assert user_created[\"success\"] is True\n    assert user_created[\"user_email\"] == \"testuser-permcheck@test.org\"\n    assert (\n        \"User account created. Please verify your email address to log in.\"\n        in user_created[\"messages\"]\n    )\n\n    # verify our email\n    emailverify = actions.set_user_emailaddr_verified(\n        {\n            \"email\": user_payload[\"email\"],\n            \"user_id\": user_created[\"user_id\"],\n            \"pii_salt\": \"super-secret-salt\",\n            \"reqid\": 1,\n        },\n        override_authdb_path=\"sqlite:///test-permcheck.authdb.sqlite\",\n    )\n\n    # make a non-verified user\n    user_payload2 = {\n        \"full_name\": \"Test User\",\n        \"email\": \"testuser-permcheck2@test.org\",\n        \"password\": \"aROwQin9L8nNtPTEMLXd\",\n        \"pii_salt\": \"super-secret-salt\",\n        \"reqid\": 1,\n    }\n    user_created2 = actions.create_new_user(\n        user_payload2,\n        override_authdb_path=\"sqlite:///test-permcheck.authdb.sqlite\",\n    )\n    assert user_created2[\"success\"] is True\n    assert user_created2[\"user_email\"] == \"testuser-permcheck2@test.org\"\n    assert (\n        \"User account created. Please verify your email address to log in.\"\n        in user_created2[\"messages\"]\n    )\n\n    #\n    # now run the permissions checks\n    #\n\n    # get the permissions JSON\n    thisdir = os.path.dirname(__file__)\n    permissions_json = os.path.abspath(\n        os.path.join(thisdir, \"..\", \"default-permissions-model.json\")\n    )\n\n    # 1. view a non-owned public object\n    access_check = actions.check_user_access(\n        {\n            \"user_id\": emailverify[\"user_id\"],\n            \"user_role\": \"authenticated\",\n            \"action\": \"view\",\n            \"target_name\": \"object\",\n            \"target_owner\": 1,\n            \"target_visibility\": \"public\",\n            \"target_sharedwith\": \"\",\n            \"reqid\": 1,\n            \"pii_salt\": \"dummy-pii-salt\",\n        },\n        override_authdb_path=\"sqlite:///test-permcheck.authdb.sqlite\",\n        override_permissions_json=permissions_json,\n        raiseonfail=True,\n    )\n    assert access_check[\"success\"] is True\n    assert (\n        \"Access request check successful. Access granted: True.\"\n        in access_check[\"messages\"]\n    )\n\n    # 2. delete a non-owned public object\n    access_check = actions.check_user_access(\n        {\n            \"user_id\": emailverify[\"user_id\"],\n            \"user_role\": \"authenticated\",\n            \"action\": \"delete\",\n            \"target_name\": \"object\",\n            \"target_owner\": 1,\n            \"target_visibility\": \"public\",\n            \"target_sharedwith\": \"\",\n            \"reqid\": 1,\n            \"pii_salt\": \"dummy-pii-salt\",\n        },\n        override_authdb_path=\"sqlite:///test-permcheck.authdb.sqlite\",\n        override_permissions_json=permissions_json,\n        raiseonfail=True,\n    )\n    assert access_check[\"success\"] is False\n    assert (\n        \"Access request check successful. Access granted: False.\"\n        in access_check[\"messages\"]\n    )\n\n    # 3. edit a self owned dataset\n    access_check = actions.check_user_access(\n        {\n            \"user_id\": emailverify[\"user_id\"],\n            \"user_role\": \"authenticated\",\n            \"action\": \"edit\",\n            \"target_name\": \"dataset\",\n            \"target_owner\": emailverify[\"user_id\"],\n            \"target_visibility\": \"private\",\n            \"target_sharedwith\": \"\",\n            \"reqid\": 1,\n            \"pii_salt\": \"dummy-pii-salt\",\n        },\n        override_authdb_path=\"sqlite:///test-permcheck.authdb.sqlite\",\n        override_permissions_json=permissions_json,\n        raiseonfail=True,\n    )\n    assert access_check[\"success\"] is True\n    assert (\n        \"Access request check successful. Access granted: True.\"\n        in access_check[\"messages\"]\n    )\n\n    # 3. as superuser, delete someone else's private dataset\n    access_check = actions.check_user_access(\n        {\n            \"user_id\": 1,\n            \"user_role\": \"superuser\",\n            \"action\": \"delete\",\n            \"target_name\": \"dataset\",\n            \"target_owner\": 4,\n            \"target_visibility\": \"private\",\n            \"target_sharedwith\": \"\",\n            \"reqid\": 1,\n            \"pii_salt\": \"dummy-pii-salt\",\n        },\n        override_authdb_path=\"sqlite:///test-permcheck.authdb.sqlite\",\n        override_permissions_json=permissions_json,\n        raiseonfail=True,\n    )\n    assert access_check[\"success\"] is True\n    assert (\n        \"Access request check successful. Access granted: True.\"\n        in access_check[\"messages\"]\n    )\n\n    # 4. as locked user, try to view a public collection\n    access_check = actions.check_user_access(\n        {\n            \"user_id\": 3,\n            \"user_role\": \"locked\",\n            \"action\": \"view\",\n            \"target_name\": \"collection\",\n            \"target_owner\": 1,\n            \"target_visibility\": \"public\",\n            \"target_sharedwith\": \"\",\n            \"reqid\": 1,\n            \"pii_salt\": \"dummy-pii-salt\",\n        },\n        override_authdb_path=\"sqlite:///test-permcheck.authdb.sqlite\",\n        override_permissions_json=permissions_json,\n        raiseonfail=True,\n    )\n    assert access_check[\"success\"] is False\n    assert (\n        \"Access request check successful. Access granted: False.\"\n        in access_check[\"messages\"]\n    )\n\n    # 5. as an unknown user with superuser privileges, try to edit a private\n    # dataset\n    access_check = actions.check_user_access(\n        {\n            \"user_id\": 10,\n            \"user_role\": \"superuser\",\n            \"action\": \"edit\",\n            \"target_name\": \"dataset\",\n            \"target_owner\": 1,\n            \"target_visibility\": \"private\",\n            \"target_sharedwith\": \"\",\n            \"reqid\": 1,\n            \"pii_salt\": \"dummy-pii-salt\",\n        },\n        override_authdb_path=\"sqlite:///test-permcheck.authdb.sqlite\",\n        override_permissions_json=permissions_json,\n        raiseonfail=True,\n    )\n    assert access_check[\"success\"] is False\n    assert (\n        \"Access request check successful. Access granted: False.\"\n        in access_check[\"messages\"]\n    )\n\n    # 6. as a known user but non-activated account, try to view a collection\n    access_check = actions.check_user_access(\n        {\n            \"user_id\": 5,\n            \"user_role\": \"authenticated\",\n            \"action\": \"view\",\n            \"target_name\": \"collection\",\n            \"target_owner\": 1,\n            \"target_visibility\": \"public\",\n            \"target_sharedwith\": \"\",\n            \"reqid\": 1,\n            \"pii_salt\": \"dummy-pii-salt\",\n        },\n        override_authdb_path=\"sqlite:///test-permcheck.authdb.sqlite\",\n        override_permissions_json=permissions_json,\n        raiseonfail=True,\n    )\n    assert access_check[\"success\"] is False\n    assert (\n        \"Access request check successful. Access granted: False.\"\n        in access_check[\"messages\"]\n    )\n\n    #\n    # teardown\n    #\n\n    currproc = mp.current_process()\n    if getattr(currproc, \"authdb_meta\", None):\n        del currproc.authdb_meta\n\n    if getattr(currproc, \"connection\", None):\n        currproc.authdb_conn.close()\n        del currproc.authdb_conn\n\n    if getattr(currproc, \"authdb_engine\", None):\n        currproc.authdb_engine.dispose()\n        del currproc.authdb_engine\n\n    try:\n        os.remove(\"test-permcheck.authdb.sqlite\")\n    except Exception:\n        pass\n    try:\n        os.remove(\"test-permcheck.authdb.sqlite-shm\")\n    except Exception:\n        pass\n    try:\n        os.remove(\"test-permcheck.authdb.sqlite-wal\")\n    except Exception:\n        pass", "label": "victim", "fix": "23a24,50\n >  user_payload = {'full_name': 'Test User', 'email': 'testuser-sessiondelete@test.org', 'password': 'aROwQin9L8nNtPTEMLXd', 'pii_salt': 'super-secret-salt', 'reqid': 1}\n >  user_created = actions.create_new_user(user_payload, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  emailverify = actions.set_user_emailaddr_verified({'email': user_payload['email'], 'user_id': user_created['user_id'], 'pii_salt': 'super-secret-salt', 'reqid': 1}, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  assert (emailverify['success'] is True)\n >  assert (emailverify['user_role'] == 'authenticated')\n >  session_payload = {'user_id': emailverify['user_id'], 'user_agent': 'Mozzarella Killerwhale', 'expires': (datetime.utcnow() + timedelta(hours=1)), 'ip_address': '1.1.1.1', 'extra_info_json': {'pref_datasets_always_private': True}, 'pii_salt': 'super-secret-salt', 'reqid': 1}\n >  session_token1 = actions.auth_session_new(session_payload, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  session_payload = {'user_id': emailverify['user_id'], 'user_agent': 'Searchzilla Oxide', 'expires': (datetime.utcnow() + timedelta(hours=1)), 'ip_address': '1.1.1.2', 'extra_info_json': {'pref_datasets_always_private': True}, 'pii_salt': 'super-secret-salt', 'reqid': 1}\n >  session_token2 = actions.auth_session_new(session_payload, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  session_payload = {'user_id': emailverify['user_id'], 'user_agent': 'Pear Adventure', 'expires': (datetime.utcnow() + timedelta(hours=1)), 'ip_address': '1.1.1.3', 'extra_info_json': {'pref_datasets_always_private': True}, 'pii_salt': 'super-secret-salt', 'reqid': 1}\n >  session_token3 = actions.auth_session_new(session_payload, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  sessions_killed = actions.auth_delete_sessions_userid({'user_id': emailverify['user_id'], 'session_token': session_token3['session_token'], 'keep_current_session': True, 'pii_salt': 'super-secret-salt', 'reqid': 1}, raiseonfail=True, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  assert (sessions_killed['success'] is True)\n >  session_check_1 = actions.auth_session_exists({'session_token': session_token1['session_token'], 'pii_salt': 'super-secret-salt', 'reqid': 1}, raiseonfail=True, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  assert (session_check_1['success'] is False)\n >  session_check_2 = actions.auth_session_exists({'session_token': session_token2['session_token'], 'pii_salt': 'super-secret-salt', 'reqid': 1}, raiseonfail=True, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  assert (session_check_2['success'] is False)\n >  session_check_3 = actions.auth_session_exists({'session_token': session_token3['session_token'], 'pii_salt': 'super-secret-salt', 'reqid': 1}, raiseonfail=True, override_authdb_path='sqlite:///test-sessiondelete.authdb.sqlite')\n >  assert (session_check_3['success'] is True)\n >  currproc = mp.current_process()\n >  if getattr(currproc, 'authdb_engine', None):\n >  currproc.authdb_engine.dispose()\n >  del currproc.authdb_engine\n >  try:\n >  os.remove('test-sessiondelete.authdb.sqlite')\n >  except Exception:\n >  pass"}
{"code": "def test_toJSON(self):\n\t\t# model.factory.context_uri = 'http://lod.getty.edu/context.json'\n\t\texpect = OrderedDict([\n\t\t\t('@context', model.factory.context_uri),\n\t\t\t('id', u'http://lod.example.org/museum/InformationObject/collection'), \n\t\t\t('type', 'InformationObject'), ('_label', 'Test Object')])\n\t\toutj = model.factory.toJSON(self.collection)\n\t\tself.assertEqual(expect, outj)", "label": "victim", "fix": "77a78\n >  model.factory.context_uri = 'https://linked.art/ns/v1/linked-art.json'"}
{"code": "def test_toJSON_fast(self):\n\t\tmodel.factory.json_serializer = \"fast\"\n\t\texpect = {'@context': model.factory.context_uri, \n\t\t\t'id': 'http://lod.example.org/museum/InformationObject/collection', \n\t\t\t'type': 'InformationObject', \n\t\t\t'_label': 'Test Object'}\n\t\toutj = model.factory.toJSON(self.collection)\n\t\tself.assertEqual(expect, outj)\n\t\tmodel.factory.json_serializer = \"normal\"", "label": "victim", "fix": "85a86\n >  model.factory.context_uri = 'https://linked.art/ns/v1/linked-art.json'"}
{"code": "def test_toString(self):\n\t\texpect = u'{\"@context\":\"'+model.factory.context_uri+'\",\"id\":\"http://lod.example.org/museum/InformationObject/collection\",\"type\":\"InformationObject\",\"_label\":\"Test Object\"}'\n\t\touts = model.factory.toString(self.collection)\n\t\tself.assertEqual(expect, outs)", "label": "victim", "fix": "107a108\n >  model.factory.context_uri = 'https://linked.art/ns/v1/linked-art.json'"}
{"code": "def test_toString_fast(self):\n\t\t# Should only be trusted in python 3\n\t\tif sys.version_info.major >= 3 and sys.version_info.minor >= 6:\n\t\t\texpect = u'{\"@context\":\"'+model.factory.context_uri+'\",\"id\":\"http://lod.example.org/museum/InformationObject/collection\",\"type\":\"InformationObject\",\"_label\":\"Test Object\"}'\n\t\t\tmodel.factory.json_serializer = \"fast\"\t\t\n\t\t\touts = model.factory.toString(self.collection)\n\t\t\tmodel.factory.json_serializer = \"normal\"\n\t\t\tself.assertEqual(expect, outs)\n\t\telse:\n\t\t\tprint(\"Skipping toString_fast test in Python 2.x\")", "label": "victim", "fix": "113a114\n >  model.factory.context_uri = 'https://linked.art/ns/v1/linked-art.json'"}
{"code": "def test_breadth(self):\n\t\tx = model.TransferOfCustody()\n\t\te = model.Activity()\n\t\tfr = model.Group()\n\t\tto = model.Group()\n\t\tw = model.HumanMadeObject()\n\t\tfr._label = \"From\"\n\t\tto._label = \"To\"\n\t\tx.transferred_custody_of = w\n\t\tx.transferred_custody_from = fr\n\t\tx.transferred_custody_to = to\n\t\te.used_specific_object = w\n\t\te.carried_out_by = to\n\t\tw.current_owner = fr\n\t\tx.specific_purpose = e\n\t\tjs = model.factory.toJSON(x)\n\t\t# Okay ... if we're breadth first, then custody_from is a resource\n\t\t# And now it's the first in the list\n\t\tself.assertTrue(isinstance(js['transferred_custody_from'][0], OrderedDict))", "label": "victim", "fix": "135a136\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_string_list(self):\n\t\tx = model.Activity()\n\t\tx._label = [\"Label 1\", \"Label 2\"]\n\t\tjs = model.factory.toJSON(x)\n\t\tself.assertTrue(js['_label'] == x._label)", "label": "victim", "fix": "155a156\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_recursion(self):\n\t\tx = model.Activity()\n\t\tx.part = x\n\t\tjs = model.factory.toJSON(x)\n\t\t# If our recursion checks have regressed, this will barf right here\n\t\tself.assertTrue(1)", "label": "victim", "fix": "171a172\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_pipe_scoped(self):\n\t\tx = model.Activity()\n\t\ty = model.Activity()\n\t\tx.part = y\n\t\tmodel.factory.pipe_scoped_contexts = True\n\t\tjs = model.factory.toJSON(x)\n\t\tself.assertTrue('part|crm:P9_consists_of' in js)\n\t\tmodel.factory.pipe_scoped_contexts = False\n\t\tjs = model.factory.toJSON(x)\t\t\n\t\tself.assertTrue('part|crm:P9_consists_of' not in js)\t\t\n\t\tself.assertTrue('part' in js)", "label": "victim", "fix": "178a179\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_collapse_json(self):\n\t\tmodel.factory.auto_id_type = \"uuid\"\n\t\tmodel.factory.base_url = \"http://lod.example.org/museum/\"\n\t\tmodel.factory.context_uri = \"https://linked.art/ns/v1/linked-art.json\"\n\t\tp = model.Person()\n\t\tp.classified_as = model.Type(ident=\"http://example.org/Type\", label=\"Test\")\n\t\tres1 = model.factory.toString(p, compact=False, collapse=60) # all new lines\n\t\tres2 = model.factory.toString(p, compact=False, collapse=120) # compact list of type\n\t\tself.assertEqual(len(res1.splitlines()), 12)\n\t\tself.assertEqual(len(res2.splitlines()), 6)", "label": "victim", "fix": "190a191\n >  model.factory.auto_assign_id = True"}
{"code": "def test_production_mode(self):\n\n\t\t# model.factory.production_mode()\n\t\t# Can't unset the cached hierarchy\n\t\t# and it causes the test for the hierarchy to fail\n\t\tmodel.factory.validate_profile = False\n\t\tmodel.factory.validate_properties = False\n\t\tmodel.factory.validate_range = False\n\t\tmodel.factory.validate_multiplicity = False\n\n\t\tp = model.Person()\n\t\tp.identified_by = model.Name(value=\"abc\")\n\t\tp.part = model.HumanMadeObject()\n\t\tjs = model.factory.toJSON(p)\n\n\t\tmodel.factory.production_mode(state=False)", "label": "victim", "fix": "205a206\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_ordering(self):\n\t\tp = model.Person(label=\"Person\")\n\t\tp.classified_as = model.Type(ident=\"type-uri\")\n\t\tp.referred_to_by = model.LinguisticObject(content=\"text\")\n\t\tp.dimension = model.Dimension(value=1)\n\n\t\toutstr = model.factory.toString(p)\n\t\tlbl = outstr.index(\"_label\")\n\t\tclsf = outstr.index(\"classified_as\")\n\t\tr2b = outstr.index(\"referred_to_by\")\n\t\tdim = outstr.index(\"dimension\")\n\t\tself.assertTrue(lbl < clsf)\n\t\tself.assertTrue(clsf < r2b)\n\t\tself.assertTrue(r2b < dim)", "label": "victim", "fix": "219a220\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_no_ident(self):\n\n\t\tmodel.factory.auto_assign_id = True\n\t\tp1 = model.Person()\t# auto assigned\t \n\t\tp2 = model.Person(ident=None) # auto assigned\n\t\tp3 = model.Person(ident=\"\") # bnode explicitly\n\n\t\tself.assertTrue(p1.id.startswith('http'))\n\t\tself.assertTrue(p2.id.startswith('http'))\n\t\tself.assertEqual(p3.id, '')\n\n\t\tmodel.factory.auto_assign_id = False\n\t\tp4 = model.Person() # bnode is default\n\t\tp5 = model.Person(ident=None) # bnode is default\n\t\tp6 = model.Person(ident=\"\") # bnode explicitly\n\n\t\tself.assertEqual(p4.id, '')\n\t\tself.assertEqual(p5.id, '')\n\t\tself.assertEqual(p6.id, '')", "label": "victim", "fix": "337a338\n >  model.factory.auto_id_type = 'int'"}
{"code": "def test_init(self):\n\t\tself.assertEqual(self.artist.id, 'http://lod.example.org/museum/Person/00001')\n\t\tself.assertEqual(self.artist._type, 'crm:E21_Person')\n\t\tself.assertEqual(self.artist.type, 'Person')\n\t\tself.assertEqual(self.artist._label, 'Jane Doe')\n\t\tself.assertFalse(hasattr(self.artist, 'value'))\n\t\tself.assertFalse(hasattr(self.artist, 'has_type'))", "label": "victim", "fix": "421a422\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_list_my_props(self):\n\t\tp1 = model.Person()\n\t\tp1.classified_as = model.Type()\n\t\tprops = p1.list_my_props()\n\t\tself.assertEqual(set(props), set(['classified_as', 'id']))\n\t\tprops = p1.list_my_props(filter=model.Type)\n\t\tself.assertEqual(props, ['classified_as'])", "label": "victim", "fix": "385a386\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_allows_multiple(self):\n\t\tp = model.Person()\n\t\tself.assertTrue(p.allows_multiple('classified_as'))\n\t\tself.assertFalse(p.allows_multiple('born'))\n\t\tself.assertRaises(model.DataError, p.allows_multiple, 'fish')", "label": "victim", "fix": "393a394\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_multiplicity(self):\n\t\tmodel.factory.process_multiplicity = True\n\t\twho = model.Actor()\n\t\tmmo = model.HumanMadeObject()\n\t\tprod = model.Production()\n\t\tmmo.produced_by = prod\n\t\twho.current_owner_of = mmo\n\t\tmmo.current_owner = who\n\t\tself.assertEqual(mmo.current_owner, [who])\n\t\tself.assertEqual(who.current_owner_of, [mmo])\t\t\n\t\tself.assertEqual(mmo.produced_by, prod)", "label": "victim", "fix": "409a410\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_init_params(self):\n\t\tp1 = model.Person(ident=\"urn:uuid:1234\")\n\t\tself.assertEqual(p1.id, \"urn:uuid:1234\")\n\t\tp2 = model.Person(ident=\"http://schema.org/Foo\")\n\t\tself.assertEqual(p2.id, \"schema:Foo\")\n\t\tp3 = model.Name(content=\"Test\")\n\t\tself.assertEqual(p3.content, \"Test\")\n\t\tc = model.MonetaryAmount(value=10)\n\t\tself.assertEqual(c.value, 10)\n\t\tn = model.Name(value=\"Rob\")\n\t\tself.assertEqual(n.content, \"Rob\")\n\t\ti = model.Identifier(content=\"xyz123\")\n\t\tself.assertEqual(i.content, \"xyz123\")\n\t\ti2 = model.Identifier(value=\"abc\")\n\t\tself.assertEqual(i2.content, \"abc\")", "label": "victim", "fix": "421a422\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_cache_hierarchy(self):\n\t\to = model.HumanMadeObject()\n\t\tself.assertEqual(o._all_properties, {})\n\t\tmodel.factory.cache_hierarchy()\n\t\tself.assertTrue(len(o._all_properties) > 50)", "label": "victim", "fix": "444a445\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_validate_profile_off(self):\n\t\tmodel.factory.validate_profile = False\n\t\tia = model.IdentifierAssignment()\n\t\t# If it's not turned off this should raise\n\t\tmodel.factory.validate_profile = True\n\t\tself.assertRaises(model.ProfileError, model.IdentifierAssignment)\t\t\n\t\tp1 = model.Person()\n\t\tself.assertRaises(model.ProfileError, p1.__setattr__, 'documented_in', \"foo\")", "label": "victim", "fix": "491a492\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_validate_multiplicity(self):\n\t\tmodel.factory.validate_multiplicity = True\n\t\twho = model.Person()\n\t\tb1 = model.Birth()\n\t\twho.born = b1\n\t\tb2 = model.Birth()\n\t\tself.assertRaises(model.ProfileError, who.__setattr__, 'born', b2)\n\t\tmodel.factory.validate_multiplicity = False\n\t\twho.born = b2\n\t\tself.assertEqual(who.born, [b1, b2])", "label": "victim", "fix": "517a518\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_not_multiple_instance(self):\n\t\twho = model.Person()\n\t\tn = model.Name(content=\"Test\")\n\t\twho.identified_by = n\n\n\t\tmodel.factory.multiple_instances_per_property = \"error\"\n\t\tself.assertRaises(model.DataError, who.__setattr__, 'identified_by', n)\n\t\tself.assertEqual(who.identified_by, [n])\n\n\t\tmodel.factory.multiple_instances_per_property = \"drop\"\n\t\twho.identified_by = n\n\t\tself.assertEqual(who.identified_by, [n,n])\t\t\n\t\t# and check that only serialized once\n\t\tjs = model.factory.toJSON(who)\n\t\tself.assertEqual(len(js['identified_by']), 1)\n\n\t\tmodel.factory.multiple_instances_per_property = \"allow\"\n\t\tjs = model.factory.toJSON(who)\n\t\tself.assertEqual(len(js['identified_by']), 2)", "label": "victim", "fix": "528a529\n >  model.factory.auto_id_type = 'uuid'"}
{"code": "def test_rule_without_fix(self):\n        cli_args = _create_arg_parser().parse_args([\"test_rule_without_fix\"])\n        reload(config)\n        config.REPORTER = MemoryReporter\n        linter = Linter(cli_args, config)\n        lines, reporter = linter.lint_lines(\"test_rule_without_fix\", self.TEST_INPUT)\n\n        self.assertEqual(reporter.found_issues[Category.CONVENTION], 1)\n        self.assertEqual(reporter.found_issues[Category.REFACTOR], 0)\n        self.assertEqual(reporter.found_issues[Category.WARNING], 0)\n        self.assertEqual(reporter.found_issues[Category.ERROR], 0)\n        self.assertEqual(reporter.found_issues[Category.FATAL], 0)\n\n        self.assertEqual(lines, self.TEST_INPUT)\n\n        self.assertEqual(reporter.messages[0].line_number, 0)\n        self.assertEqual(reporter.messages[0].column, 16)\n        self.assertEqual(reporter.messages[0].message, \"trailing whitespace\")\n        self.assertEqual(reporter.messages[0].code, \"trailing-whitespace\")", "label": "victim", "fix": "14a15,18\n >  cli_args = _create_arg_parser().parse_args(['--fix', 'test_rule_with_fix'])\n >  linter = Linter(cli_args, config)\n >  (lines, _) = linter.lint_lines('test_rule_with_fix', self.TEST_INPUT)\n >  self.assertEqual(lines, self.FIXED_INPUT)"}
{"code": "def test_rule_with_fix(self):\n        cli_args = _create_arg_parser().parse_args([\"--fix\", \"test_rule_with_fix\"])\n        reload(config)\n        config.REPORTER = MemoryReporter\n        linter = Linter(cli_args, config)\n        lines, _ = linter.lint_lines(\"test_rule_with_fix\", self.TEST_INPUT)\n\n        self.assertEqual(lines, self.FIXED_INPUT)", "label": "victim", "fix": "34a35,40\n >  cli_args = _create_arg_parser().parse_args(['test_rule_without_fix'])\n >  reload(config)\n >  config.REPORTER = MemoryReporter\n >  linter = Linter(cli_args, config)\n >  (lines, reporter) = linter.lint_lines('test_rule_without_fix', self.TEST_INPUT)\n >  self.assertEqual(reporter.found_issues[Category.CONVENTION], 1)"}
{"code": "def test_rule_without_fix(self):\n        cli_args = _create_arg_parser().parse_args([\"test_rule_without_fix\"])\n        reload(config)\n        config.REPORTER = MemoryReporter\n        linter = Linter(cli_args, config)\n        lines, reporter = linter.lint_lines(\"test_rule_without_fix\", self.TEST_INPUT)\n\n        self.assertEqual(reporter.found_issues[Category.CONVENTION], 0)\n        self.assertEqual(reporter.found_issues[Category.REFACTOR], 0)\n        self.assertEqual(reporter.found_issues[Category.WARNING], 1)\n        self.assertEqual(reporter.found_issues[Category.ERROR], 0)\n        self.assertEqual(reporter.found_issues[Category.FATAL], 0)\n\n        self.assertEqual(lines, self.TEST_INPUT)\n\n        self.assertEqual(reporter.messages[0].line_number, 0)\n        self.assertEqual(reporter.messages[0].column, 0)\n        self.assertEqual(reporter.messages[0].message, \"lower or mixed case built-in type\")\n        self.assertEqual(reporter.messages[0].code, \"wrong-case-type\")", "label": "victim", "fix": "14a15,18\n >  cli_args = _create_arg_parser().parse_args(['--fix', 'test_rule_with_fix'])\n >  linter = Linter(cli_args, config)\n >  (lines, _) = linter.lint_lines('test_rule_with_fix', self.TEST_INPUT)\n >  self.assertEqual(lines, self.FIXED_INPUT)"}
{"code": "def test_rule_with_fix(self):\n        cli_args = _create_arg_parser().parse_args([\"--fix\", \"test_rule_with_fix\"])\n        reload(config)\n        config.REPORTER = MemoryReporter\n        linter = Linter(cli_args, config)\n        lines, _ = linter.lint_lines(\"test_rule_with_fix\", self.TEST_INPUT)\n\n        self.assertEqual(lines, self.FIXED_INPUT)", "label": "victim", "fix": "34a35,40\n >  cli_args = _create_arg_parser().parse_args(['test_rule_without_fix'])\n >  reload(config)\n >  config.REPORTER = MemoryReporter\n >  linter = Linter(cli_args, config)\n >  (lines, reporter) = linter.lint_lines('test_rule_without_fix', self.TEST_INPUT)\n >  self.assertEqual(reporter.found_issues[Category.CONVENTION], 1)"}
{"code": "def test_rule_without_fix(self):\n        cli_args = _create_arg_parser().parse_args([\"test_rule_without_fix\"])\n        reload(config)\n        config.REPORTER = MemoryReporter\n        linter = Linter(cli_args, config)\n        lines, reporter = linter.lint_lines(\"test_rule_without_fix\", self.TEST_INPUT)\n\n        self.assertEqual(reporter.found_issues[Category.CONVENTION], 0)\n        self.assertEqual(reporter.found_issues[Category.REFACTOR], 0)\n        self.assertEqual(reporter.found_issues[Category.WARNING], 3)\n        self.assertEqual(reporter.found_issues[Category.ERROR], 0)\n        self.assertEqual(reporter.found_issues[Category.FATAL], 0)\n\n        self.assertEqual(lines, self.TEST_INPUT)\n\n        self.assertEqual(reporter.messages[0].line_number, 1)\n        self.assertEqual(reporter.messages[0].column, 6)\n        self.assertEqual(reporter.messages[0].message, \"wrong indentation (found 6 spaces, exptected 3)\")\n        self.assertEqual(reporter.messages[0].code, \"bad-indentation\")\n\n        self.assertEqual(reporter.messages[1].line_number, 4)\n        self.assertEqual(reporter.messages[1].column, 3)\n        self.assertEqual(reporter.messages[1].message, \"wrong indentation (found 3 spaces, exptected 0)\")\n        self.assertEqual(reporter.messages[1].code, \"bad-indented-inline-form\")\n\n        self.assertEqual(reporter.messages[2].line_number, 5)\n        self.assertEqual(reporter.messages[2].column, 3)\n        self.assertEqual(reporter.messages[2].message, \"wrong indentation (found 3 spaces, exptected 0)\")\n        self.assertEqual(reporter.messages[2].code, \"bad-indented-inline-form\")", "label": "victim", "fix": "14a15,18\n >  cli_args = _create_arg_parser().parse_args(['--fix', 'test_rule_with_fix'])\n >  linter = Linter(cli_args, config)\n >  (lines, _) = linter.lint_lines('test_rule_with_fix', self.TEST_INPUT)\n >  self.assertEqual(lines, self.FIXED_INPUT)"}
{"code": "def test_rule_with_fix(self):\n        cli_args = _create_arg_parser().parse_args([\"--fix\", \"test_rule_with_fix\"])\n        reload(config)\n        config.REPORTER = MemoryReporter\n        linter = Linter(cli_args, config)\n        lines, _ = linter.lint_lines(\"test_rule_with_fix\", self.TEST_INPUT)\n\n        self.assertEqual(lines, self.FIXED_INPUT)", "label": "victim", "fix": "34a35,40\n >  cli_args = _create_arg_parser().parse_args(['test_rule_without_fix'])\n >  reload(config)\n >  config.REPORTER = MemoryReporter\n >  linter = Linter(cli_args, config)\n >  (lines, reporter) = linter.lint_lines('test_rule_without_fix', self.TEST_INPUT)\n >  self.assertEqual(reporter.found_issues[Category.CONVENTION], 1)"}
{"code": "def test_rule_without_fix(self):\n        cli_args = _create_arg_parser().parse_args([\"test_rule_without_fix\"])\n        reload(config)\n        config.REPORTER = MemoryReporter\n        linter = Linter(cli_args, config)\n        lines, reporter = linter.lint_lines(\"test_rule_without_fix\", self.TEST_INPUT)\n\n        self.assertEqual(reporter.found_issues[Category.CONVENTION], 0)\n        self.assertEqual(reporter.found_issues[Category.REFACTOR], 0)\n        self.assertEqual(reporter.found_issues[Category.WARNING], 1)\n        self.assertEqual(reporter.found_issues[Category.ERROR], 0)\n        self.assertEqual(reporter.found_issues[Category.FATAL], 0)\n\n        self.assertEqual(lines, self.TEST_INPUT)\n\n        self.assertEqual(reporter.messages[0].line_number, 0)\n        self.assertEqual(reporter.messages[0].column, 0)\n        self.assertEqual(reporter.messages[0].message, \"complete open task (This is a open task)\")\n        self.assertEqual(reporter.messages[0].code, \"open-task\")", "label": "victim", "fix": "14a15,18\n >  cli_args = _create_arg_parser().parse_args(['--fix', 'test_rule_with_fix'])\n >  linter = Linter(cli_args, config)\n >  (lines, _) = linter.lint_lines('test_rule_with_fix', self.TEST_INPUT)\n >  self.assertEqual(lines, self.FIXED_INPUT)"}
{"code": "def test_rule_with_fix(self):\n        cli_args = _create_arg_parser().parse_args([\"--fix\", \"test_rule_with_fix\"])\n        reload(config)\n        config.REPORTER = MemoryReporter\n        linter = Linter(cli_args, config)\n        lines, _ = linter.lint_lines(\"test_rule_with_fix\", self.TEST_INPUT)\n\n        self.assertEqual(lines, self.TEST_INPUT)", "label": "victim", "fix": "34a35,40\n >  cli_args = _create_arg_parser().parse_args(['test_rule_without_fix'])\n >  reload(config)\n >  config.REPORTER = MemoryReporter\n >  linter = Linter(cli_args, config)\n >  (lines, reporter) = linter.lint_lines('test_rule_without_fix', self.TEST_INPUT)\n >  self.assertEqual(reporter.found_issues[Category.CONVENTION], 1)"}
{"code": "def test_rule_without_fix(self):\n        cli_args = _create_arg_parser().parse_args([\"test_rule_without_fix\"])\n        reload(config)\n        config.REPORTER = MemoryReporter\n        linter = Linter(cli_args, config)\n        lines, reporter = linter.lint_lines(\"test_rule_without_fix\", self.TEST_INPUT)\n\n        self.assertEqual(reporter.found_issues[Category.CONVENTION], 1)\n        self.assertEqual(reporter.found_issues[Category.REFACTOR], 0)\n        self.assertEqual(reporter.found_issues[Category.WARNING], 0)\n        self.assertEqual(reporter.found_issues[Category.ERROR], 0)\n        self.assertEqual(reporter.found_issues[Category.FATAL], 0)\n\n        self.assertEqual(lines, self.TEST_INPUT)\n\n        self.assertEqual(reporter.messages[0].line_number, 0)\n        self.assertEqual(reporter.messages[0].column, 3)\n        self.assertEqual(reporter.messages[0].message, \"superfluous whitespace\")\n        self.assertEqual(reporter.messages[0].code, \"superfluous-whitespace\")", "label": "victim", "fix": "14a15,18\n >  cli_args = _create_arg_parser().parse_args(['--fix', 'test_rule_with_fix'])\n >  linter = Linter(cli_args, config)\n >  (lines, _) = linter.lint_lines('test_rule_with_fix', self.TEST_INPUT)\n >  self.assertEqual(lines, self.FIXED_INPUT)"}
{"code": "def test_rule_with_fix(self):\n        cli_args = _create_arg_parser().parse_args([\"--fix\", \"test_rule_with_fix\"])\n        reload(config)\n        config.REPORTER = MemoryReporter\n        linter = Linter(cli_args, config)\n        lines, _ = linter.lint_lines(\"test_rule_with_fix\", self.TEST_INPUT)\n\n        self.assertEqual(lines, self.FIXED_INPUT)", "label": "victim", "fix": "34a35,40\n >  cli_args = _create_arg_parser().parse_args(['test_rule_without_fix'])\n >  reload(config)\n >  config.REPORTER = MemoryReporter\n >  linter = Linter(cli_args, config)\n >  (lines, reporter) = linter.lint_lines('test_rule_without_fix', self.TEST_INPUT)\n >  self.assertEqual(reporter.found_issues[Category.CONVENTION], 1)"}
{"code": "def test_rule_without_fix(self):\n        cli_args = _create_arg_parser().parse_args([\"test_rule_without_fix\"])\n        reload(config)\n        config.REPORTER = MemoryReporter\n        linter = Linter(cli_args, config)\n        lines, reporter = linter.lint_lines(\"test_rule_without_fix\", self.TEST_INPUT)\n\n        self.assertEqual(reporter.found_issues[Category.CONVENTION], 0)\n        self.assertEqual(reporter.found_issues[Category.REFACTOR], 0)\n        self.assertEqual(reporter.found_issues[Category.WARNING], 1)\n        self.assertEqual(reporter.found_issues[Category.ERROR], 0)\n        self.assertEqual(reporter.found_issues[Category.FATAL], 0)\n\n        self.assertEqual(lines, self.TEST_INPUT)\n\n        self.assertEqual(reporter.messages[0].line_number, 0)\n        self.assertEqual(reporter.messages[0].column, 0)\n        self.assertEqual(reporter.messages[0].message, \"lower or mixed case keyword\")\n        self.assertEqual(reporter.messages[0].code, \"wrong-case-keyword\")", "label": "victim", "fix": "14a15,18\n >  cli_args = _create_arg_parser().parse_args(['--fix', 'test_rule_with_fix'])\n >  linter = Linter(cli_args, config)\n >  (lines, _) = linter.lint_lines('test_rule_with_fix', self.TEST_INPUT)\n >  self.assertEqual(lines, self.FIXED_INPUT)"}
{"code": "def test_rule_with_fix(self):\n        cli_args = _create_arg_parser().parse_args([\"--fix\", \"test_rule_with_fix\"])\n        reload(config)\n        config.REPORTER = MemoryReporter\n        linter = Linter(cli_args, config)\n        lines, _ = linter.lint_lines(\"test_rule_with_fix\", self.TEST_INPUT)\n\n        self.assertEqual(lines, self.FIXED_INPUT)", "label": "victim", "fix": "34a35,40\n >  cli_args = _create_arg_parser().parse_args(['test_rule_without_fix'])\n >  reload(config)\n >  config.REPORTER = MemoryReporter\n >  linter = Linter(cli_args, config)\n >  (lines, reporter) = linter.lint_lines('test_rule_without_fix', self.TEST_INPUT)\n >  self.assertEqual(reporter.found_issues[Category.CONVENTION], 1)"}
{"code": "def test_parse_response(self):\n        \"\"\" Should parse requests response. \"\"\"\n        params = {'message': 'foo'}\n        headers = {'content-type': 'application/json'}\n        req = self.create_request(url='http://localhost:5000/',\n                                  method='POST',\n                                  data=params,\n                                  headers=headers)\n\n        res = self.send(req, params, 'data/post.json')\n        self.autodoc.parse('POST /', res)\n\n        var = {\n            'describe': 'POST /',\n            'describe_separators': '======',\n            'target_url': 'http://localhost:5000/',\n            'status_code': 200,\n            'request': 'POST /',\n            'response_body': '{\\n  \"response\": \"create\"\\n}',\n            'response_content_type': 'application/json',\n            'params': '{\\n  \"message\": \"foo\"\\n}'\n        }\n        for k, v in iteritems(self.autodoc.vars[0]):\n            self.assertEqual(v, var[k])\n\n        self.autodoc.clear()", "label": "victim", "fix": "42a43\n >  autodoc.clear()"}
{"code": "def test_parse_responses(self):\n        \"\"\" Should stack responses. \"\"\"\n        headers = {'content-type': 'application/json'}\n        req = self.create_request(url='http://localhost:5000/',\n                                  method='GET',\n                                  headers=headers)\n\n        res = self.send(req, '', 'data/get.json')\n        self.autodoc.parse('GET /', res)\n        self.autodoc.parse('GET /', res)\n        var = {\n            'response_content_type': 'application/json',\n            'response_body': '{\\n  \"response\": \"index\"\\n}',\n            'describe': 'GET /',\n            'request': 'GET /',\n            'params': '',\n            'status_code': 200,\n            'target_url': 'http://localhost:5000/',\n            'describe_separators': '====='\n        }\n        vars = [var, var]\n        self.assertEqual(self.autodoc.vars, vars)\n        self.autodoc.clear()", "label": "victim", "fix": "62a63\n >  autodoc.clear()"}
{"code": "def test_create_document(self):\n        \"\"\" Should create reST document. \"\"\"\n        headers = {'content-type': 'application/json'}\n        req = self.create_request(url='http://localhost:5000/',\n                                  method='GET',\n                                  headers=headers)\n\n        res = self.send(req, '', 'data/get.json')\n\n        self.autodoc.parse('GET /', res)\n        self.autodoc.create_document(os.path.join(self.root_path,\n                                                  'var/test_autodoc.rst'))\n        self.assertTrue(os.path.exists(os.path.join(self.root_path,\n                                                    'var/test_autodoc.rst')))\n        self.autodoc.clear()", "label": "victim", "fix": "89a90,93\n >  ' Should create markdown document. '\n >  res = self.client.get('/')\n >  autodoc.parse('GET /', res)\n >  autodoc.template_path = os.path.join(self.root_path, 'templates/markdown.md')"}
{"code": "def test_should_change_separators(self):\n        \"\"\" Should change separators. \"\"\"\n        headers = {'content-type': 'application/json'}\n        req = self.create_request(url='http://localhost:5000/',\n                                  method='GET',\n                                  headers=headers)\n        res = self.send(req, '', 'data/get.json')\n\n        self.autodoc.separators = '*'\n        self.autodoc.parse('GET /', res)\n        var = {\n            'response_content_type': 'application/json',\n            'response_body': '{\\n  \"response\": \"index\"\\n}',\n            'describe': 'GET /',\n            'request': 'GET /',\n            'params': '',\n            'status_code': 200,\n            'target_url': 'http://localhost:5000/',\n            'describe_separators': '*****'\n        }\n        for k, v in iteritems(self.autodoc.vars[0]):\n            self.assertEqual(v, var[k])\n\n        self.autodoc.clear()", "label": "victim", "fix": "111a112\n >  autodoc.clear()"}
{"code": "def test_parse_response(self):\n        \"\"\" Should parse WebTest response. \"\"\"\n        res = self.client.post_json('/', params={'message': 'foo'})\n        autodoc.parse('POST /', res)\n\n        var = {\n            'describe': 'POST /',\n            'describe_separators': '======',\n            'target_url': 'http://localhost:80',\n            'status_code': 200,\n            'request': 'POST /',\n            'response_body': '{\\n  \"response\": \"create\"\\n}',\n            'response_content_type': 'application/json',\n            'params': '{\\n  \"message\": \"foo\"\\n}'\n        }\n        for k, v in iteritems(autodoc.vars[0]):\n            self.assertEqual(v, var[k])\n\n        autodoc.clear()", "label": "victim", "fix": "42a43\n >  autodoc.clear()"}
{"code": "def test_parse_responses(self):\n        \"\"\" Should stack responses. \"\"\"\n        res = self.client.get('/')\n        autodoc.parse('GET /', res)\n        autodoc.parse('GET /', res)\n        var = {\n            'response_content_type': 'application/json',\n            'response_body': '{\\n  \"response\": \"index\"\\n}',\n            'describe': 'GET /',\n            'request': 'GET /',\n            'params': '',\n            'status_code': 200,\n            'target_url': 'http://localhost:80',\n            'describe_separators': '====='\n        }\n        vars = [var, var]\n        self.assertEqual(autodoc.vars, vars)\n        autodoc.clear()", "label": "victim", "fix": "62a63\n >  autodoc.clear()"}
{"code": "def test_create_document(self):\n        \"\"\" Should create reST document. \"\"\"\n        res = self.client.get('/')\n        autodoc.parse('GET /', res)\n        autodoc.create_document(os.path.join(self.root_path,\n                                             'var/test_autodoc.rst'))\n        self.assertTrue(os.path.exists(os.path.join(self.root_path,\n                                                    'var/test_autodoc.rst')))\n        autodoc.clear()", "label": "victim", "fix": "89a90,93\n >  ' Should create markdown document. '\n >  res = self.client.get('/')\n >  autodoc.parse('GET /', res)\n >  autodoc.template_path = os.path.join(self.root_path, 'templates/markdown.md')"}
{"code": "def test_should_change_separators(self):\n        \"\"\" Should change separators. \"\"\"\n        res = self.client.get('/')\n        autodoc.separators = '*'\n        autodoc.parse('GET /', res)\n        var = {\n            'response_content_type': 'application/json',\n            'response_body': '{\\n  \"response\": \"index\"\\n}',\n            'describe': 'GET /',\n            'request': 'GET /',\n            'params': '',\n            'status_code': 200,\n            'target_url': 'http://localhost:80',\n            'describe_separators': '*****'\n        }\n        for k, v in iteritems(autodoc.vars[0]):\n            self.assertEqual(v, var[k])\n\n        autodoc.clear()", "label": "victim", "fix": "111a112\n >  autodoc.clear()"}
